https://blog.csdn.net/as02446418/article/details/47699547

<img src="https://img-blog.csdn.net/20150816083054461" />

### 1. crear a heap

从空的堆开始，然后依次往堆中插入每一个元素，直到所有数都被插入（转移到堆中为止）
。因为插入第i个元素的所用的时间是O(log i)，所以插入所有元素的整体时间复杂度是O(NlogN)，代码如下。
```
n=0;
for(i=1;i<=m;i++)
{
    n++;
    h[ n]=a[ i];  //或者写成scanf("%d",&h[ n]);
    siftup();
}
```
更快得方法来建立堆:
直接把放入一个完全二叉树中（这里我们还是用一个一维数组来存储完全二叉树）。 因为叶结点没有儿子，
所以所有以叶结点为根结点的子树（其实这个子树只有一个结点）都符合最小堆的特性（即父结点的值比子结点的值小）。
这些叶结点压根就没有子节点，
当然符合这个特性。因此所有叶结点都不需要处理，直接跳过。
从第n/2个结点（n为完全二叉树的结点总数，这里即7号结点）开始处理这棵完全二叉树。
用这种方法来建立一个堆的时间复杂度是O(N)

堆排序，与快速排序一样堆排序的时间复杂度也是O(NlogN)。
比如我们现在要进行从小到大排序，可以先建立最小堆，
然后每次删除顶部元素并将顶部元素输出或者放入一个新的数组中，直到堆为空为止。最终输出的或者存放在新数组中数就已经是排序好的了。

堆排序还有一种更好的方法。从小到大排序的时候不建立最小堆而建立最大堆。
最大堆建立好后，最大的元素在h[ 1]。
因为我们的需求是从小到大排序，希望最大的放在最后。因此我们将h[ 1]和h[ n]交换，此时h[ n]就是数组中的最大的元素。
请注意，交换后还需将h[ 1]向下调整以保持堆的特性。
OK现在最大的元素已经归位，需要将堆的大小减1即n–，然后再将h[ 1]和h[ n]交换，并将h[ 1]向下调整。
如此反复，直到堆的大小变成1为止。此时数组h中的数就已经是排序好的了。



作者：罗拙呓 
来源：CSDN 
原文：https://blog.csdn.net/as02446418/article/details/47699547 
版权声明：本文为博主原创文章，转载请附上博文链接！
